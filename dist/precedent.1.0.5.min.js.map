{"version":3,"sources":["precedent.1.0.5.min.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","libWordTree","libStringParser","Precedent","this","WordTree","StringParser","ParseTree","value","pPatternStart","pPatternEnd","pParser","addPattern","pString","parseString","./StringParser.js","./WordTree.js","2","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","pNode","pParserState","hasOwnProperty","pCharacter","PatternEnd","PatternStart","substr","Parse","flushOutputBuffer","assignNode","appendOutputBuffer","checkPatternEnd","tmpParserState","newParserState","parseCharacter","3","pTree","pPattern","pIndex","tmpLeaf","addChild","pData"],"mappings":"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","file":"precedent.1.0.5.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(\"./WordTree.js\");\nvar libStringParser = require(\"./StringParser.js\");\n\nvar Precedent = function () {\n\t/**\n  * Precedent Constructor\n  */\n\tfunction Precedent() {\n\t\t_classCallCheck(this, Precedent);\n\n\t\tthis.WordTree = new libWordTree();\n\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\n\t/**\n  * Add a Pattern to the Parse Tree\n  * @method addPattern\n  * @param {Object} pTree - A node on the parse tree to push the characters into\n  * @param {string} pPattern - The string to add to the tree\n  * @param {number} pIndex - callback function\n  * @return {bool} True if adding the pattern was successful\n  */\n\n\n\t_createClass(Precedent, [{\n\t\tkey: \"addPattern\",\n\t\tvalue: function addPattern(pPatternStart, pPatternEnd, pParser) {\n\t\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t\t}\n\n\t\t/**\n   * Parse a string with the existing parse tree\n   * @method parseString\n   * @param {string} pString - The string to parse\n   * @return {string} The result from the parser\n   */\n\n\t}, {\n\t\tkey: \"parseString\",\n\t\tvalue: function parseString(pString) {\n\t\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t\t}\n\t}]);\n\n\treturn Precedent;\n}();\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":2,\"./WordTree.js\":3}],2:[function(require,module,exports){\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nvar StringParser = function () {\n\t/**\n  * StringParser Constructor\n  */\n\tfunction StringParser() {\n\t\t_classCallCheck(this, StringParser);\n\t}\n\n\t/**\n  * Create a fresh parsing state object to work with.\n  * @method newParserState\n  * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n  * @return {Object} A new parser state object for running a character parser on\n  * @private\n  */\n\n\n\t_createClass(StringParser, [{\n\t\tkey: 'newParserState',\n\t\tvalue: function newParserState(pParseTree) {\n\t\t\treturn {\n\t\t\t\tParseTree: pParseTree,\n\n\t\t\t\tOutput: '',\n\t\t\t\tOutputBuffer: '',\n\n\t\t\t\tPattern: false,\n\n\t\t\t\tPatternMatch: false,\n\t\t\t\tPatternMatchOutputBuffer: ''\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Assign a node of the parser tree to be the next potential match.\n   * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n   * @method assignNode\n   * @param {Object} pNode - A node on the parse tree to assign\n   * @param {Object} pParserState - The state object for the current parsing task\n   * @private\n   */\n\n\t}, {\n\t\tkey: 'assignNode',\n\t\tvalue: function assignNode(pNode, pParserState) {\n\t\t\tpParserState.PatternMatch = pNode;\n\n\t\t\t// If the pattern has a END we can assume it has a parse function...\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd')) {\n\t\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Append a character to the output buffer in the parser state.\n   * This output buffer is used when a potential match is being explored, or a match is being explored.\n   * @method appendOutputBuffer\n   * @param {string} pCharacter - The character to append\n   * @param {Object} pParserState - The state object for the current parsing task\n   * @private\n   */\n\n\t}, {\n\t\tkey: 'appendOutputBuffer',\n\t\tvalue: function appendOutputBuffer(pCharacter, pParserState) {\n\t\t\tpParserState.OutputBuffer += pCharacter;\n\t\t}\n\n\t\t/**\n   * Flush the output buffer to the output and clear it.\n   * @method flushOutputBuffer\n   * @param {Object} pParserState - The state object for the current parsing task\n   * @private\n   */\n\n\t}, {\n\t\tkey: 'flushOutputBuffer',\n\t\tvalue: function flushOutputBuffer(pParserState) {\n\t\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\t\tpParserState.OutputBuffer = '';\n\t\t}\n\n\t\t/**\n   * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n   * @method checkPatternEnd\n   * @param {Object} pParserState - The state object for the current parsing task\n   * @private\n   */\n\n\t}, {\n\t\tkey: 'checkPatternEnd',\n\t\tvalue: function checkPatternEnd(pParserState) {\n\t\t\tif (pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length + pParserState.Pattern.PatternStart.length && pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd) {\n\t\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length + pParserState.Pattern.PatternEnd.length)));\n\t\t\t\t// Flush the output buffer.\n\t\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t\t// End pattern mode\n\t\t\t\tpParserState.Pattern = false;\n\t\t\t\tpParserState.PatternMatch = false;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Parse a character in the buffer.\n   * @method parseCharacter\n   * @param {string} pCharacter - The character to append\n   * @param {Object} pParserState - The state object for the current parsing task\n   * @private\n   */\n\n\t}, {\n\t\tkey: 'parseCharacter',\n\t\tvalue: function parseCharacter(pCharacter, pParserState) {\n\t\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter)) {\n\t\t\t\t// ... assign the node as the matched node.\n\t\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t}\n\t\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\t\telse if (pParserState.PatternMatch) {\n\t\t\t\t\t// If the pattern has a subpattern with this key\n\t\t\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter)) {\n\t\t\t\t\t\t// Continue matching patterns.\n\t\t\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t\t\t}\n\t\t\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\t\t\tif (pParserState.Pattern) {\n\t\t\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\t\t\telse {\n\t\t\t\t\t\tpParserState.Output += pCharacter;\n\t\t\t\t\t}\n\t\t}\n\n\t\t/**\n   * Parse a string for matches, and process any template segments that occur.\n   * @method parseString\n   * @param {string} pString - The string to parse.\n   * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n   */\n\n\t}, {\n\t\tkey: 'parseString',\n\t\tvalue: function parseString(pString, pParseTree) {\n\t\t\tvar tmpParserState = this.newParserState(pParseTree);\n\n\t\t\tfor (var i = 0; i < pString.length; i++) {\n\t\t\t\t// TODO: This is not fast.\n\t\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t\t}\n\n\t\t\tthis.flushOutputBuffer(tmpParserState);\n\n\t\t\treturn tmpParserState.Output;\n\t\t}\n\t}]);\n\n\treturn StringParser;\n}();\n\nmodule.exports = StringParser;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nvar WordTree = function () {\n\t/**\n  * WordTree Constructor\n  */\n\tfunction WordTree() {\n\t\t_classCallCheck(this, WordTree);\n\n\t\tthis.ParseTree = {};\n\t}\n\n\t/** \n  * Add a child character to a Parse Tree node\n  * @method addChild\n  * @param {Object} pTree - A parse tree to push the characters into\n  * @param {string} pPattern - The string to add to the tree\n  * @param {number} pIndex - callback function\n  * @returns {Object} The resulting leaf node that was added (or found)\n  * @private\n  */\n\n\n\t_createClass(WordTree, [{\n\t\tkey: 'addChild',\n\t\tvalue: function addChild(pTree, pPattern, pIndex) {\n\t\t\tif (pIndex > pPattern.length) return pTree;\n\n\t\t\tif (!pTree.hasOwnProperty(pPattern[pIndex])) pTree[pPattern[pIndex]] = {};\n\n\t\t\treturn pTree[pPattern[pIndex]];\n\t\t}\n\n\t\t/** Add a Pattern to the Parse Tree\n   * @method addPattern\n   * @param {Object} pTree - A node on the parse tree to push the characters into\n   * @param {string} pPattern - The string to add to the tree\n   * @param {number} pIndex - callback function\n   * @return {bool} True if adding the pattern was successful\n   */\n\n\t}, {\n\t\tkey: 'addPattern',\n\t\tvalue: function addPattern(pPatternStart, pPatternEnd, pParser) {\n\t\t\tif (pPatternStart.length < 1) return false;\n\n\t\t\tvar tmpLeaf = this.ParseTree;\n\n\t\t\t// Add the tree of leaves iteratively\n\t\t\tfor (var i = 0; i < pPatternStart.length; i++) {\n\t\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\t\t\t}tmpLeaf.PatternStart = pPatternStart;\n\t\t\ttmpLeaf.PatternEnd = typeof pPatternEnd === 'string' && pPatternEnd.length > 0 ? pPatternEnd : pPatternStart;\n\t\t\ttmpLeaf.Parse = typeof pParser === 'function' ? pParser : typeof pParser === 'string' ? function () {\n\t\t\t\treturn pParser;\n\t\t\t} : function (pData) {\n\t\t\t\treturn pData;\n\t\t\t};\n\n\t\t\treturn true;\n\t\t}\n\t}]);\n\n\treturn WordTree;\n}();\n\nmodule.exports = WordTree;\n\n},{}]},{},[1]);\n"]}